<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tic Tac Toe — Open Coding (Hacks)</title>
  <link rel="stylesheet" href="/csse_teamrepo/assets/css/style.css" />
  <style>
    :root{ --bg:#041014; --card:#0b1a1f; --text:#e6f7ff; --accent:#4fd1c5 }
    .ttt-theme-light{ --bg:#fff; --card:#f7f9fc; --text:#0b1a1f; --accent:#2b6cb0 }
    .ttt-theme-dark{ --bg:#041014; --card:#07202a; --text:#e6f7ff; --accent:#4fd1c5 }
    .ttt-theme-blue{ --bg:#0f1724; --card:#07213a; --text:#dbeafe; --accent:#60a5fa }
    body{ background:var(--bg); color:var(--text); font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; padding:1rem }
    main{ max-width:920px; margin:0 auto }
    .card{ background:var(--card); padding:12px; border-radius:8px }
    #tictactoe-board{ display:grid; gap:8px; margin-top:12px }
    .ttt-cell{ display:flex;align-items:center;justify-content:center;font-size:1.6rem;background:transparent;color:var(--text);border:1px solid rgba(255,255,255,0.06);cursor:pointer }
    .ttt-cell:hover{ background:rgba(255,255,255,0.02) }
    .controls{ display:flex;gap:12px;flex-wrap:wrap;align-items:center }
    button, select{ background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--text);padding:6px 10px;border-radius:6px }
    a{ color:var(--accent) }
  </style>
</head>
<body class="ttt-theme-dark">
  <main>
    <h1>Tic-Tac-Toe (Hacks)</h1>
    <div class="card">
      <p>Play a configurable in-browser Tic-Tac-Toe. Use controls to change size, theme, mode, and difficulty.</p>

      <div class="controls" style="margin-bottom:8px">
        <label>Mode:
          <select id="ttt-mode"><option value="pvp">Player vs Player</option><option value="pva">Player vs AI</option></select>
        </label>
        <label>AI difficulty:
          <select id="ttt-ai"><option value="easy">Easy</option><option value="medium">Medium</option><option value="hard">Hard</option></select>
        </label>
        <label>Board size:
          <select id="ttt-size"><option value="3">3 × 3</option><option value="4">4 × 4</option></select>
        </label>
        <label>Theme:
          <select id="ttt-theme"><option value="dark" selected>Black / Dark</option><option value="white">White / Light</option><option value="bluepurple">Blue / Purple</option><option value="teal">Teal / Cyan</option></select>
        </label>
        <button id="ttt-reset">New Round</button>
        <button id="ttt-reset-scores">Reset Scores</button>
      </div>

      <div style="display:flex;gap:18px;align-items:center;flex-wrap:wrap;margin-bottom:8px">
        <div><strong>Score</strong><div id="ttt-scores">X: 0 • O: 0 • Ties: 0</div></div>
        <div style="min-width:220px"><div id="ttt-status" style="font-weight:600">X to move</div></div>
      </div>

      <div id="tictactoe-app">
        <div id="tictactoe-board" role="grid" aria-label="Tic Tac Toe board"></div>
      </div>
    </div>

    <p style="margin-top:10px"><a href="/csse_teamrepo/games/tictactoe">Back to post</a> • <a href="/csse_teamrepo/hacks/TicTacToe/TicTacToe.html">Lesson: OOP overview</a></p>
  </main>

    <script>
    (function(){
      const boardEl = document.getElementById('tictactoe-board');
      const statusEl = document.getElementById('ttt-status');
      const resetBtn = document.getElementById('ttt-reset');
      const resetScoresBtn = document.getElementById('ttt-reset-scores');
      const modeSelect = document.getElementById('ttt-mode');
      const aiSelect = document.getElementById('ttt-ai');
      const sizeSelect = document.getElementById('ttt-size');
      const themeSelect = document.getElementById('ttt-theme');

      let size = Number(sizeSelect.value) || 3;
      let winLen = size === 3 ? 3 : size;
      let board = Array(size*size).fill('');
      let turn = 'X';
      let scores = { X:0, O:0, ties:0 };

      function applyTheme(theme){
        document.body.classList.remove('ttt-theme-dark','ttt-theme-white','ttt-theme-bluepurple','ttt-theme-teal');
        document.body.classList.add('ttt-theme-' + theme);
      }

      function render(){
        boardEl.style.gridTemplateColumns = `repeat(${size}, ${size===4? '80px':'90px'})`;
        boardEl.innerHTML = '';
        board.forEach((val,i)=>{
          const cell = document.createElement('div');
          cell.className = 'ttt-cell';
          cell.style.width = (size===4? '80px':'90px');
          cell.style.height = (size===4? '80px':'90px');
          cell.setAttribute('data-index', i);
          cell.setAttribute('role','button');
          cell.textContent = val;
          cell.addEventListener('click', onCellClick);
          boardEl.appendChild(cell);
        });
        const winner = checkWinner();
        if(winner){ statusEl.textContent = `${winner} wins!`; }
        else if(board.every(Boolean)){ statusEl.textContent = 'Tie'; }
        else { statusEl.textContent = `${turn} to move`; }
        updateScoresDisplay();
      }

      function rcToIndex(r,c){ return r*size + c; }

      function onCellClick(e){
        const i = Number(e.currentTarget.dataset.index);
        if(board[i] || checkWinner()) return;
        makeMove(i, turn);
        if(modeSelect.value === 'pva' && !checkWinner() && !board.every(Boolean)){
          setTimeout(aiMove, 120);
        }
      }

      function makeMove(i, symbol){
        board[i] = symbol;
        const winner = checkWinner();
        if(winner){ scores[winner] = (scores[winner]||0)+1; }
        else if(board.every(Boolean)){ scores.ties++; }
        else { turn = (turn === 'X') ? 'O' : 'X'; }
        render();
      }

      function updateScoresDisplay(){ document.getElementById('ttt-scores').textContent = `X: ${scores.X} • O: ${scores.O} • Ties: ${scores.ties}`; }

      function checkWinner(){
        for(let r=0;r<size;r++){
          for(let c=0;c<=size-winLen;c++){
            const first = board[rcToIndex(r,c)]; if(!first) continue;
            let ok=true; for(let k=1;k<winLen;k++) if(board[rcToIndex(r,c+k)]!==first) ok=false; if(ok) return first;
          }
        }
        for(let c=0;c<size;c++){
          for(let r=0;r<=size-winLen;r++){
            const first = board[rcToIndex(r,c)]; if(!first) continue;
            let ok=true; for(let k=1;k<winLen;k++) if(board[rcToIndex(r+k,c)]!==first) ok=false; if(ok) return first;
          }
        }
        for(let r=0;r<=size-winLen;r++){
          for(let c=0;c<=size-winLen;c++){
            const first = board[rcToIndex(r,c)]; if(!first) continue;
            let ok=true; for(let k=1;k<winLen;k++) if(board[rcToIndex(r+k,c+k)]!==first) ok=false; if(ok) return first;
          }
        }
        for(let r=winLen-1;r<size;r++){
          for(let c=0;c<=size-winLen;c++){
            const first = board[rcToIndex(r,c)]; if(!first) continue;
            let ok=true; for(let k=1;k<winLen;k++) if(board[rcToIndex(r-k,c+k)]!==first) ok=false; if(ok) return first;
          }
        }
        return null;
      }

      function availableMoves(){ return board.map((v,i)=> v?null:i).filter(v=>v!==null); }

      // AI move with difficulty levels
      function aiMove(){
        const level = aiSelect.value; const aiSymbol='O'; const human='X';
        if(level === 'easy'){
          const moves = availableMoves(); if(moves.length===0) return; const pick = moves[Math.floor(Math.random()*moves.length)]; makeMove(pick, aiSymbol); return;
        }
        if(level === 'medium'){
          // try win
          for(const i of availableMoves()){ const copy=board.slice(); copy[i]=aiSymbol; if(simCheckWinner(copy, aiSymbol)){ makeMove(i, aiSymbol); return; } }
          // block
          for(const i of availableMoves()){ const copy=board.slice(); copy[i]=human; if(simCheckWinner(copy, human)){ makeMove(i, aiSymbol); return; } }
          // center
          const center = Math.floor(size*size/2); if(board[center]===''){ makeMove(center, aiSymbol); return; }
          // fallback random
          const moves = availableMoves(); if(moves.length===0) return; const pick = moves[Math.floor(Math.random()*moves.length)]; makeMove(pick, aiSymbol); return;
        }
        if(level === 'hard' && size===3){
          // minimax for 3x3
          const best = minimax(board, aiSymbol);
          if(best.move !== undefined) { makeMove(best.move, aiSymbol); return; }
        }
        // fallback for hard on larger boards
        if(level === 'hard'){
          // use medium heuristic
          for(const i of availableMoves()){ const copy=board.slice(); copy[i]=aiSymbol; if(simCheckWinner(copy, aiSymbol)){ makeMove(i, aiSymbol); return; } }
          for(const i of availableMoves()){ const copy=board.slice(); copy[i]=human; if(simCheckWinner(copy, human)){ makeMove(i, aiSymbol); return; } }
          const moves = availableMoves(); if(moves.length===0) return; const pick = moves[Math.floor(Math.random()*moves.length)]; makeMove(pick, aiSymbol); return;
        }
      }

      function simCheckWinner(simBoard, symbol){
        function valAt(r,c){ return simBoard[rcToIndex(r,c)]; }
        for(let r=0;r<size;r++){ for(let c=0;c<=size-winLen;c++){ let ok=true; for(let k=0;k<winLen;k++) if(valAt(r,c+k)!==symbol) ok=false; if(ok) return true; } }
        for(let c=0;c<size;c++){ for(let r=0;r<=size-winLen;r++){ let ok=true; for(let k=0;k<winLen;k++) if(valAt(r+k,c)!==symbol) ok=false; if(ok) return true; } }
        for(let r=0;r<=size-winLen;r++){ for(let c=0;c<=size-winLen;c++){ let ok=true; for(let k=0;k<winLen;k++) if(valAt(r+k,c+k)!==symbol) ok=false; if(ok) return true; } }
        for(let r=winLen-1;r<size;r++){ for(let c=0;c<=size-winLen;c++){ let ok=true; for(let k=0;k<winLen;k++) if(valAt(r-k,c+k)!==symbol) ok=false; if(ok) return true; } }
        return false;
      }

      // Minimax implementation for 3x3 (hard difficulty)
      function minimax(currBoard, player){
        const human = 'X'; const ai = 'O';
        const winner = evaluateBoard(currBoard);
        if(winner === ai) return {score: 1};
        if(winner === human) return {score: -1};
        if(currBoard.every(Boolean)) return {score: 0};

        const moves = availableMovesOn(currBoard);
        const isMax = (player === ai);
        let best = { score: isMax ? -Infinity : Infinity };

        for(const m of moves){
          const copy = currBoard.slice(); copy[m] = player;
          const result = minimax(copy, player === ai ? human : ai);
          if(isMax){
            if(result.score > best.score){ best = { score: result.score, move: m }; }
          } else {
            if(result.score < best.score){ best = { score: result.score, move: m }; }
          }
        }
        return best;
      }

      function evaluateBoard(bd){
        const lines = [
          [0,1,2],[3,4,5],[6,7,8],[0,3,6],[1,4,7],[2,5,8],[0,4,8],[2,4,6]
        ];
        for(const ln of lines){ const [a,b,c] = ln; if(bd[a] && bd[a]===bd[b] && bd[a]===bd[c]) return bd[a]; }
        return null;
      }

      function availableMovesOn(bd){ return bd.map((v,i)=> v?null:i).filter(v=>v!==null); }

      resetBtn.addEventListener('click', ()=>{ board = Array(size*size).fill(''); turn='X'; render(); });
      resetScoresBtn.addEventListener('click', ()=>{ scores={X:0,O:0,ties:0}; updateScoresDisplay(); render(); });
      modeSelect.addEventListener('change', ()=>{});
      aiSelect.addEventListener('change', ()=>{});
      sizeSelect.addEventListener('change', ()=>{ size = Number(sizeSelect.value); winLen = size===3?3:size; board = Array(size*size).fill(''); turn='X'; render(); });
      themeSelect.addEventListener('change', ()=> applyTheme(themeSelect.value));

      applyTheme(themeSelect.value);
      render();
    })();
  </script>
</body>
</html>
